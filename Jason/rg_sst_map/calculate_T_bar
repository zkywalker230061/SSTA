#%%
from read_nc import fix_rg_time, fix_longitude_coord
from calculate_Tm_Sm import depth_dbar_to_meter, _full_field, mld_dbar_to_meter, vertical_integral, z_to_xarray
from grad_field import compute_gradient_lat, compute_gradient_lon
import numpy as np
import pandas as pd
import xarray as xr
import gsw
import re
from tqdm import tqdm
from typing import Optional
from dask.diagnostics import ProgressBar
import matplotlib.pyplot as plt
import matplotlib
from scipy.ndimage import gaussian_filter

#%%

#---1. ---Read File--------------------------------------
temp_file_path = r"C:\Users\jason\MSciProject\RG_ArgoClim_Temperature_2019.nc"
salinity_file_path = r"C:\Users\jason\MSciProject\RG_ArgoClim_Salinity_2019.nc"
updated_h_bar_file_path = r"C:\Users\jason\MSciProject\Mixed_Layer_Depth_Pressure-Seasonal_Cycle_Mean.nc"


ds_temp = xr.open_dataset(
    temp_file_path,
    engine="netcdf4",
    decode_times=False,   # disable decoding to avoid error
    mask_and_scale=True,
)

ds_sal = xr.open_dataset(
    salinity_file_path,
    engine="netcdf4",
    decode_times=False,
    mask_and_scale=True,
)

h_bar = xr.open_dataset(
    updated_h_bar_file_path,
    engine="netcdf4",
    decode_times=False,
    mask_and_scale=True
)


T_mean = ds_temp["ARGO_TEMPERATURE_MEAN"]
T_anom = ds_temp["ARGO_TEMPERATURE_ANOMALY"]
T_full = _full_field(T_mean, T_anom)
T_full = fix_longitude_coord(T_full)


def month_idx (time_da: xr.DataArray) -> xr.DataArray:
    n = time_da.sizes['TIME']
    # Repeat 1..12 along TIME; align coords to TIME
    month_idx = (xr.DataArray(np.arange(n) % 12 + 1, dims=['TIME'])
                 .assign_coords(TIME=time_da))
    month_idx.name = 'MONTH'
    return month_idx

def get_monthly_mean(da: xr.DataArray,) -> xr.DataArray:
    if 'TIME' not in da.dims:
        raise ValueError("The DataArray must have a TIME dimension.")
    
    m = month_idx(da['TIME'])
    monthly_mean_da = da.groupby(m).mean('TIME', keep_attrs=True)
    # monthly_means = []
    # for _, month_num in MONTHS.items():
    #     monthly_means.append(
    #         da.sel(TIME=da['TIME'][month_num-1::12]).mean(dim='TIME')
    #     )
    # monthly_mean_da = xr.concat(monthly_means, dim='MONTH')
    # monthly_mean_da = monthly_mean_da.assign_coords(MONTH=list(MONTHS.values()))
    # monthly_mean_da['MONTH'].attrs['units'] = 'month'
    # monthly_mean_da['MONTH'].attrs['axis'] = 'M'
    # monthly_mean_da.attrs['units'] = da.attrs.get('units')
    # monthly_mean_da.attrs['long_name'] = f"Seasonal Cycle Mean of {da.attrs.get('long_name')}"
    # monthly_mean_da.name = f"MONTHLY_MEAN_{da.name}"
    return monthly_mean_da

def load_pressure_data(path: str, varname: str, *, compute_time_mode: str = "datetime",) -> xr.DataArray:
    """Load MLD in PRESSURE units, fix time, convert to meters (positive down)."""

    ds = xr.open_dataset(path, engine="netcdf4", decode_times=False, mask_and_scale=True)
    ds = fix_rg_time(ds, mode=compute_time_mode)

    pressure = ds[varname] # Coordinates = (TIME: 180, LATITUDE: 145, LONGITUDE: 360)
    lat_1D = ds["LATITUDE"]
    lat_3D = xr.broadcast(lat_1D, pressure)[0].transpose(*pressure.dims)
    depth_m   = mld_dbar_to_meter(pressure, lat_3D)
    depth_m   = fix_longitude_coord(depth_m)

    # print('depth_bar:\n',depth_bar, depth_bar.shape)
    # print(lat_3D)
    # print('depth_m:\n',depth_m)
    # print('depth_m after fix_longitude:\n', depth_m)
    return depth_m

ds_Tbar_monthly = get_monthly_mean(T_full)                                           # MONTH: 12, PRESSURE: 58, LATITUDE: 145, LONGITUDE: 360)
ds_h_bar_monthly = load_pressure_data(updated_h_bar_file_path,                       # MONTH: 12, LATITUDE: 145, LONGITUDE: 360
                                      'MONTHLY_MEAN_MLD_PRESSURE', 
                                      compute_time_mode="none")

print('ds_Tbar_monthly:\n', ds_Tbar_monthly)
print('ds_h_bar_monthly:\n', ds_h_bar_monthly)

#----3. gsw--------------------------------------------
p = ds_temp['PRESSURE']
lat = ds_temp['LATITUDE']
depth = depth_dbar_to_meter(p,lat)

ZDIM = "PRESSURE"
YDIM = "LATITUDE"
XDIM = "LONGITUDE"
TDIM = "TIME"
T_VAR = "ARGO_TEMPERATURE_MEAN"
S_VAR = "ARGO_SALINITY_MEAN"
T_VAR_ANOMALY = "ARGO_TEMPERATURE_ANOMALY"

dz = z_to_xarray(depth, ds_Tbar_monthly)                 #TIME: 180, PRESSURE: 58, LATITUDE: 145, LONGITUDE: 360
print(dz)

#%%
#----4. Vertical Integration -------------------------------
temp_mld_bar = vertical_integral(ds_Tbar_monthly, dz, ds_h_bar_monthly)
smoothed_data = np.zeros_like(temp_mld_bar.values)

for t in range(temp_mld_bar.shape[0]):
    # Extract the 2D slice for this month
    data_slice = temp_mld_bar.values[t, :, :]
    
    # 1. Create a Mask: Where is the data valid? (1 = Ocean, 0 = Land)
    mask = ~np.isnan(data_slice)
    
    # 2. Replace NaNs with 0 temporarily so the filter doesn't crash
    data_filled = data_slice.copy()
    data_filled[~mask] = 0
    
    # 3. Smooth the Data (Zeros included)
    smoothed_values = gaussian_filter(data_filled, sigma=1.0)
    
    # 4. Smooth the Mask (To count how much "valid weight" each pixel got)
    smoothed_weights = gaussian_filter(mask.astype(float), sigma=1.0)
    
    # 5. Normalize: Divide smoothed data by smoothed weights
    # This effectively cancels out the impact of the zeros we added
    with np.errstate(invalid='ignore', divide='ignore'):
        result = smoothed_values / smoothed_weights
    
    # 6. Re-apply the original Land Mask (Optional: keeps land as NaN)
    result[~mask] = np.nan
    
    smoothed_data[t, :, :] = result

temp_mld_bar.values = smoothed_data
#%%
print('vertical_integral:\n', temp_mld_bar)
#%% ----5. Gradient Test --------
gradient_lat = compute_gradient_lat(temp_mld_bar)
print('gradient_lat:\n',gradient_lat)

gradient_lon = compute_gradient_lon(temp_mld_bar)
print('gradient_lon:\n',gradient_lon)

grad_mag = np.sqrt(gradient_lat**2 + gradient_lon**2)
print('grad_mag:\n',grad_mag)



# output_path1 = r"C:\Users\jason\MSciProject\Mixed_Layer_Temperature_Seasonal_Cycle_Mean.nc"
output_path2 = r"C:\Users\jason\MSciProject\Mixed_Layer_Temperature_Gradient_Lat_SmoothTest.nc"
output_path3 = r"C:\Users\jason\MSciProject\Mixed_Layer_Temperature_Gradient_Lon_SmoothTest.nc"

# temp_mld_bar.to_dataset(name="temp_mld_mean").to_netcdf(output_path1)
gradient_lat.to_dataset(name="temp_gradient_lat").to_netcdf(output_path2)
gradient_lon.to_dataset(name="temp_gradient_lon").to_netcdf(output_path3)

#%%
print(matplotlib.__version__)
#%%
if __name__ == "__main__":
    #----Plot Temperature Map----------------------------------------------------
    date = 7
    t0 = temp_mld_bar.sel(MONTH=date)

    # Copy the colormap and set NaN color
    cmap = plt.get_cmap("RdYlBu_r").copy()
    cmap.set_bad(color="black")   # or "white", "black", (0.5,0.5,0.5,1), etc.

    plt.figure(figsize=(10,5))
    pc = plt.pcolormesh(
        t0["LONGITUDE"], t0["LATITUDE"], np.ma.masked_invalid(t0),
        cmap=cmap, shading="auto", vmin=-5, vmax=35
    )
    plt.colorbar(pc, label="Mean Temperature (°C)")
    plt.title(f"Mixed Layer Temperature - {date}")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.tight_layout()
    plt.show()
    #----Plot Gradient Map (Lat)----------------------------------------------------
    t0 = gradient_lat.sel(MONTH=date)

    # Copy the colormap and set NaN color
    cmap = plt.get_cmap("RdYlBu_r").copy()
    cmap.set_bad(color="black")   # or "white", "black", (0.5,0.5,0.5,1), etc.

    plt.figure(figsize=(10,5))
    pc = plt.pcolormesh(
        t0["LONGITUDE"], t0["LATITUDE"], np.ma.masked_invalid(t0),
        cmap=cmap, shading="auto", vmin= -1e-5, vmax=1e-5
    )
    plt.colorbar(pc, label="Temperature Gradient (°C/m)")
    plt.title(f"Mixed Layer Temperature Gradient (Lat)- {date}")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.tight_layout()
    plt.show()

    #----Plot Gradient Map (Lon)----------------------------------------------------
    t0 = gradient_lon.sel(MONTH=7)

    # Copy the colormap and set NaN color
    cmap = plt.get_cmap("RdYlBu_r").copy()
    cmap.set_bad(color="black")   # or "white", "black", (0.5,0.5,0.5,1), etc.

    plt.figure(figsize=(10,5))
    pc = plt.pcolormesh(
        t0["LONGITUDE"], t0["LATITUDE"], np.ma.masked_invalid(t0),
        cmap=cmap, shading="auto", vmin = -1e-5, vmax=1e-5
    )
    plt.colorbar(pc, label="Temperature Gradient (°C/m)")
    plt.title(f"Mixed Layer Temperature Gradient (Lon)- {date}")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.tight_layout()
    plt.show()

    
# %%
